(window.webpackJsonp=window.webpackJsonp||[]).push([[788],{1702:function(e,s,t){"use strict";t.r(s),s.default=t.p+"assets/images/message-correlation-f4f13de741bb19f5f42e0292ab1456ab.png"},1703:function(e,s,t){"use strict";t.r(s),s.default=t.p+"assets/images/message-aggregator-1dbf88f6e2c7145aa238721cbf3570f1.png"},1704:function(e,s,t){"use strict";t.r(s),s.default=t.p+"assets/images/message-single-instance-0ecb1804dba659e08c28d4520a3e72b6.png"},855:function(e,s,t){"use strict";t.r(s),t.d(s,"frontMatter",(function(){return i})),t.d(s,"metadata",(function(){return c})),t.d(s,"rightToc",(function(){return o})),t.d(s,"default",(function(){return p}));var n=t(3),a=t(7),r=(t(0),t(874)),i={id:"messages",title:"Messages"},c={unversionedId:"product-manuals/concepts/messages",id:"product-manuals/concepts/messages",isDocsHomePage:!1,title:"Messages",description:"Process instances can respond to incoming messages. Published messages need to be mapped onto a process instance. This step is called message correlation.",source:"@site/docs/product-manuals/concepts/messages.md",slug:"/product-manuals/concepts/messages",permalink:"/docs/product-manuals/concepts/messages",editUrl:"https://github.com/camunda-cloud/camunda-cloud-documentation/edit/master/docs/product-manuals/concepts/messages.md",version:"current",sidebar:"Product Manuals",previous:{title:"Process instance creation",permalink:"/docs/product-manuals/concepts/process-instance-creation"},next:{title:"Incidents",permalink:"/docs/product-manuals/concepts/incidents"}},o=[{value:"Message subscriptions",id:"message-subscriptions",children:[]},{value:"Message buffering",id:"message-buffering",children:[]},{value:"Message cardinality",id:"message-cardinality",children:[]},{value:"Message uniqueness",id:"message-uniqueness",children:[]},{value:"Message patterns",id:"message-patterns",children:[{value:"Message aggregator",id:"message-aggregator",children:[]},{value:"Single instance",id:"single-instance",children:[]}]}],l={rightToc:o};function p(e){var s=e.components,i=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},l,i,{components:s,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Process instances can respond to incoming messages. Published messages need to be mapped onto a process instance. This step is called message correlation."),Object(r.b)("h2",{id:"message-subscriptions"},"Message subscriptions"),Object(r.b)("p",null,"A message is not sent to a process instance directly. Instead, the message correlation is based on subscriptions that contains the ",Object(r.b)("em",{parentName:"p"},"message name")," and the ",Object(r.b)("em",{parentName:"p"},"correlation key")," (aka correlation value)."),Object(r.b)("p",null,Object(r.b)("img",{alt:"Message Correlation",src:t(1702).default})),Object(r.b)("p",null,"A subscription is opened when a process instance awaits a message, for example, when entering a message catch event. The message name is defined either statically in the process (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"Money collected"),") or dynamically as an expression. The correlation key is defined dynamically as an expression (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"= orderId"),"). The expressions are evaluated on activating the message catch event. The results of the evaluations are used as message name and as correlation key of the subscription (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},'"order-123"'),")."),Object(r.b)("p",null,"When a message is published and the message name and the correlation key matches to a subscription then the message is correlated to the corresponding process instance. If no proper subscription is opened then the message is discarded."),Object(r.b)("p",null,"A subscription is closed when the corresponding element (e.g. the message catch event), or its scope is left. After a subscription is opened, it is not updated, for example, when the referenced process instance variable is changed."),Object(r.b)("details",null,Object(r.b)("summary",null,"Publish message via zbctl"),Object(r.b)("p",null,Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'zbctl publish message "Money collected" --correlationKey "order-123"\n')))),Object(r.b)("h2",{id:"message-buffering"},"Message buffering"),Object(r.b)("p",null,"Messages can be buffered for a given time. Buffering can be useful in a situation when it is not guaranteed that the subscription is opened before the message is published."),Object(r.b)("p",null,"A message has a ",Object(r.b)("em",{parentName:"p"},"time-to-live")," (TTL) which specifies for how long it is buffered. Within this time, the message can be correlated to a process instance."),Object(r.b)("p",null,"When a subscription is opened then it polls the buffer for a proper message. If a proper message exists then it is correlated to the corresponding process instance. In case multiple messages match to the subscription then the first published message is correlated (like a FIFO queue)."),Object(r.b)("p",null,"The buffering of a message is disabled when its TTL is set to zero. If no proper subscription is open then the message is discarded."),Object(r.b)("details",null,Object(r.b)("summary",null,"Publish message with TTL via zbctl"),Object(r.b)("p",null,Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'zbctl publish message "Money collected" --correlationKey "order-123" --ttl 1h\n')))),Object(r.b)("h2",{id:"message-cardinality"},"Message cardinality"),Object(r.b)("p",null,"A message is correlated only ",Object(r.b)("strong",{parentName:"p"},"once")," to a process (based on the BPMN process id), across all versions of this process. If multiple subscriptions for the same process are opened (by multiple process instances or within one instance) then the message is correlated only to one of the subscriptions."),Object(r.b)("p",null,"When subscriptions are opened for different processes then the message is correlated to ",Object(r.b)("strong",{parentName:"p"},"all")," of the subscriptions."),Object(r.b)("p",null,"A message is ",Object(r.b)("strong",{parentName:"p"},"not")," correlated to a message start event subscription if an instance of the process is active and was created by a message with the same correlation key. If the message is buffered then it can be correlated after the active instance is ended. Otherwise, it is discarded."),Object(r.b)("h2",{id:"message-uniqueness"},"Message uniqueness"),Object(r.b)("p",null,"A message can have an optional message id - a unique id to ensure that the message is published and processed only once (i.e. idempotency). The id can be any string, for example, a request id, a tracking number or the offset/position in a message queue."),Object(r.b)("p",null,"A message is rejected and not correlated if a message with the same name, the same correlation key and the same id is already buffered. After the message is discarded from the buffer, a message with the same name, correlation key and id can be published again."),Object(r.b)("p",null,"The uniqueness check is disabled when no message id is set."),Object(r.b)("details",null,Object(r.b)("summary",null,"Publish message with id via zbctl"),Object(r.b)("p",null,Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'zbctl publish message "Money collected" --correlationKey "order-123" --messageId "tracking-12345"\n')))),Object(r.b)("h2",{id:"message-patterns"},"Message patterns"),Object(r.b)("p",null,"The following patterns describe solutions to common problems what can be solved using the message correlation."),Object(r.b)("h3",{id:"message-aggregator"},"Message aggregator"),Object(r.b)("p",null,"Problem: aggregate/collect multiple messages, map-reduce, batching"),Object(r.b)("p",null,"Solution:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Message Aggregator",src:t(1703).default})),Object(r.b)("p",null,"The messages are published with a TTL > 0 and a correlation key that groups the messages per entity."),Object(r.b)("p",null,"The first message creates a new process instance. The following messages are correlated to the same process instance if they have the same correlation key."),Object(r.b)("p",null,"When the instance is ended and messages with the same correlation key are not correlated yet then a new process instance is created."),Object(r.b)("h3",{id:"single-instance"},"Single instance"),Object(r.b)("p",null,"Problem: create exactly one instance of a process"),Object(r.b)("p",null,"Solution:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Message Single Instance",src:t(1704).default})),Object(r.b)("p",null,"The message is published with a TTL = 0 and a correlation key that identifies the entity."),Object(r.b)("p",null,"The first message creates a new process instance. Following messages are discarded and do not create a new instance if they have the same correlation key and the created process instance is still active."))}p.isMDXComponent=!0},874:function(e,s,t){"use strict";t.d(s,"a",(function(){return b})),t.d(s,"b",(function(){return m}));var n=t(0),a=t.n(n);function r(e,s,t){return s in e?Object.defineProperty(e,s,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[s]=t,e}function i(e,s){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);s&&(n=n.filter((function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable}))),t.push.apply(t,n)}return t}function c(e){for(var s=1;s<arguments.length;s++){var t=null!=arguments[s]?arguments[s]:{};s%2?i(Object(t),!0).forEach((function(s){r(e,s,t[s])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(s){Object.defineProperty(e,s,Object.getOwnPropertyDescriptor(t,s))}))}return e}function o(e,s){if(null==e)return{};var t,n,a=function(e,s){if(null==e)return{};var t,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],s.indexOf(t)>=0||(a[t]=e[t]);return a}(e,s);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],s.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=a.a.createContext({}),p=function(e){var s=a.a.useContext(l),t=s;return e&&(t="function"==typeof e?e(s):c(c({},s),e)),t},b=function(e){var s=p(e.components);return a.a.createElement(l.Provider,{value:s},e.children)},u={inlineCode:"code",wrapper:function(e){var s=e.children;return a.a.createElement(a.a.Fragment,{},s)}},d=a.a.forwardRef((function(e,s){var t=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),b=p(t),d=n,m=b["".concat(i,".").concat(d)]||b[d]||u[d]||r;return t?a.a.createElement(m,c(c({ref:s},l),{},{components:t})):a.a.createElement(m,c({ref:s},l))}));function m(e,s){var t=arguments,n=s&&s.mdxType;if("string"==typeof e||n){var r=t.length,i=new Array(r);i[0]=d;var c={};for(var o in s)hasOwnProperty.call(s,o)&&(c[o]=s[o]);c.originalType=e,c.mdxType="string"==typeof e?e:n,i[1]=c;for(var l=2;l<r;l++)i[l]=t[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);