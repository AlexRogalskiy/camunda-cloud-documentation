(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{179:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return l}));var r=n(2),o=n(6),a=(n(0),n(243)),c={id:"protocols",title:"Protocols"},i={unversionedId:"product-manuals/zeebe/basics/protocols",id:"product-manuals/zeebe/basics/protocols",isDocsHomePage:!1,title:"Protocols",description:"Zeebe clients connect to brokers via a stateless gateway. For the communication",source:"@site/docs/product-manuals/zeebe/basics/protocols.md",slug:"/product-manuals/zeebe/basics/protocols",permalink:"/docs/product-manuals/zeebe/basics/protocols",editUrl:"https://github.com/camunda-cloud/camunda-cloud-documentation/edit/master/docs/product-manuals/zeebe/basics/protocols.md",version:"current",sidebar:"camundaCloud",previous:{title:"Partitions",permalink:"/docs/product-manuals/zeebe/basics/partitions"},next:{title:"Internal Processing",permalink:"/docs/product-manuals/zeebe/basics/internal-processing"}},s=[{value:"What is gRPC?",id:"what-is-grpc",children:[]},{value:"Why gRPC?",id:"why-grpc",children:[]},{value:"Supported clients",id:"supported-clients",children:[]},{value:"Handling back-pressure",id:"handling-back-pressure",children:[]}],p={rightToc:s};function l(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Zeebe clients connect to brokers via a stateless gateway. For the communication\nbetween client and gateway ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://grpc.io/"}),"gRPC")," is used. The communication protocol is defined using\nProtocol Buffers v3 (",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://developers.google.com/protocol-buffers/docs/proto3"}),"proto3"),"), and you can find it in the\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/zeebe-io/zeebe/tree/develop/gateway-protocol"}),"Zeebe repository"),"."),Object(a.b)("h2",{id:"what-is-grpc"},"What is gRPC?"),Object(a.b)("p",null,"gRPC was first developed by Google and is now an open-source project and part of the Cloud Native Computing Foundation.\nIf you\u2019re new to gRPC, the ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://grpc.io/docs/guides/index.html"}),"\u201cWhat is gRPC\u201d")," page on the project website provides a good introduction to it."),Object(a.b)("h2",{id:"why-grpc"},"Why gRPC?"),Object(a.b)("p",null,"gRPC has many nice features that make it a good fit for Zeebe. It:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"supports bi-directional streaming for opening a persistent connection and sending or receiving a stream of messages between client and server"),Object(a.b)("li",{parentName:"ul"},"uses the common http2 protocol by default"),Object(a.b)("li",{parentName:"ul"},"uses Protocol Buffers as an interface definition and data serialization mechanism\u2013specifically, Zeebe uses proto3, which supports easy client generation in ten different programming languages")),Object(a.b)("h2",{id:"supported-clients"},"Supported clients"),Object(a.b)("p",null,"At the moment, Zeebe officially supports two gRPC clients: one in ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/product-manuals/zeebe/clients/java-client/index"}),"Java"),", and one in ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/product-manuals/zeebe/clients/go-client/index"}),"Golang"),"."),Object(a.b)("p",null,"If Zeebe does not provide an officially-supported client in your target language, you can read the official ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://grpc.io/docs/quickstart/"}),"Quick Start")," page to find out how\nto create a very basic one."),Object(a.b)("p",null,"You can find a list of existing clients in the ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/zeebe-io/awesome-zeebe#clients"}),"Awesome Zeebe repository"),".\nAdditionally, a ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://zeebe.io/blog/2018/11/grpc-generating-a-zeebe-python-client/"}),"blog post")," was published with a short tutorial on how to write a new client from scratch in Python."),Object(a.b)("h2",{id:"handling-back-pressure"},"Handling back-pressure"),Object(a.b)("p",null,"When a broker receives a user request, it is written to the ",Object(a.b)("em",{parentName:"p"},"event stream")," first (see section ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/product-manuals/zeebe/basics/internal-processing"}),"Internal Processing")," for details), and processed later by the stream processor.\nIf the processing is slow or if there are many user requests in the stream, it might take too long for the processor to start processing the command.\nIf the broker keeps accepting new requests from the user, the back log increases and the processing latency can grow beyond an acceptable time.\nTo avoid such problems, Zeebe employs a back-pressure mechanism.\nWhen the broker receives more requests than it can process with an acceptable latency, it rejects some requests."),Object(a.b)("p",null,"The maximum rate of requests that can be processed by a broker depends on the processing capacity of the machine, the network latency, current load of the system and so on.\nHence, there is no fixed limit configured in Zeebe for the maximum rate of requests it accepts.\nInstead, Zeebe uses an adaptive algorithm to dynamically determine the limit of the number of inflight requests (the requests that are accepted by the broker, but not yet processed).\nThe inflight request count is incremented when a request is accepted and decremented when a response is sent back to the client.\nThe broker rejects requests when the inflight request count reaches the limit."),Object(a.b)("p",null,"When the broker rejects requests due to back-pressure, the clients can retry them with an appropriate retry strategy.\nIf the rejection rate is high, it indicates that the broker is constantly under high load.\nIn that case, it is recommended to reduce the request rate."))}l.isMDXComponent=!0},243:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=o.a.createContext({}),l=function(e){var t=o.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),d=r,h=u["".concat(c,".").concat(d)]||u[d]||b[d]||a;return n?o.a.createElement(h,i(i({ref:t},p),{},{components:n})):o.a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,c=new Array(a);c[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,c[1]=i;for(var p=2;p<a;p++)c[p]=n[p];return o.a.createElement.apply(null,c)}return o.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);