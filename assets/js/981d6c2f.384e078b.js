(self.webpackChunkcamunda_cloud_documentation=self.webpackChunkcamunda_cloud_documentation||[]).push([[11077],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(n),m=l,k=d["".concat(s,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(k,r(r({ref:t},p),{},{components:n})):a.createElement(k,r({ref:t},p))}));function m(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var u=2;u<i;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},24192:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return o},metadata:function(){return s},toc:function(){return u},default:function(){return c}});var a=n(22122),l=n(19756),i=(n(67294),n(3905)),r={id:"expressions",title:"Expressions"},o=void 0,s={unversionedId:"components/zeebe/reference/expressions",id:"version-0.25/components/zeebe/reference/expressions",isDocsHomePage:!1,title:"Expressions",description:"Expressions can be used to access variables and calculate values dynamically.",source:"@site/versioned_docs/version-0.25/components/zeebe/reference/expressions.md",sourceDirName:"components/zeebe/reference",slug:"/components/zeebe/reference/expressions",permalink:"/docs/0.25/components/zeebe/reference/expressions",editUrl:"https://github.com/camunda-cloud/camunda-cloud-documentation/edit/master/versioned_docs/version-0.25/components/zeebe/reference/expressions.md",version:"0.25",frontMatter:{id:"expressions",title:"Expressions"},sidebar:"version-0.25/Components",previous:{title:"Variables",permalink:"/docs/0.25/components/zeebe/reference/variables"},next:{title:"Message Correlation",permalink:"/docs/0.25/components/zeebe/reference/message-correlation/message-correlation"}},u=[{value:"Expressions vs. Static Values",id:"expressions-vs-static-values",children:[]},{value:"The Expression Language",id:"the-expression-language",children:[{value:"Access Variables",id:"access-variables",children:[]},{value:"Boolean Expressions",id:"boolean-expressions",children:[]},{value:"Null Checks",id:"null-checks",children:[]},{value:"String Expressions",id:"string-expressions",children:[]},{value:"Temporal Expressions",id:"temporal-expressions",children:[]},{value:"List Expressions",id:"list-expressions",children:[]},{value:"Invoke Functions",id:"invoke-functions",children:[]}]},{value:"Additional Resources",id:"additional-resources",children:[]}],p={toc:u};function c(e){var t=e.components,n=(0,l.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Expressions can be used to access variables and calculate values dynamically."),(0,i.kt)("p",null,"The following attributes of BPMN elements ",(0,i.kt)("strong",{parentName:"p"},"require")," an expression:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Sequence Flow on an Exclusive Gateway: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/exclusive-gateways/exclusive-gateways#conditions"},"condition")),(0,i.kt)("li",{parentName:"ul"},"Message Catch Event / Receive Task: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/message-events/message-events#messages"},"correlation key")),(0,i.kt)("li",{parentName:"ul"},"Multi-Instance Activity: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/multi-instance/multi-instance#defining-the-collection-to-iterate-over"},"input collection"),", ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/multi-instance/multi-instance#collecting-the-output"},"output element")),(0,i.kt)("li",{parentName:"ul"},"Input/Output Variable Mappings: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/reference/variables#inputoutput-variable-mappings"},"source"))),(0,i.kt)("p",null,"Additionally, the following attributes of BPMN elements can define an expression ",(0,i.kt)("strong",{parentName:"p"},"optionally")," instead of a static value:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Timer Catch Event: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/timer-events/timer-events#timers"},"timer definition")),(0,i.kt)("li",{parentName:"ul"},"Message Catch Event / Receive Task: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/message-events/message-events#messages"},"message name")),(0,i.kt)("li",{parentName:"ul"},"Service Task: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/service-tasks/service-tasks#task-definition"},"job type"),", ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/service-tasks/service-tasks#task-definition"},"job retries")),(0,i.kt)("li",{parentName:"ul"},"Call Activity: ",(0,i.kt)("a",{parentName:"li",href:"/docs/0.25/components/zeebe/bpmn-workflows/call-activities/call-activities#defining-the-called-workflow"},"process id"))),(0,i.kt)("h2",{id:"expressions-vs-static-values"},"Expressions vs. Static Values"),(0,i.kt)("p",null,"Some attributes of BPMN elements, like the timer definition of a timer catch event, can be defined either as a static value (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"PT2H"),") or as an expression (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"= remaingTime"),")."),(0,i.kt)("p",null,"The value is identified as an expression if it starts with an ",(0,i.kt)("strong",{parentName:"p"},"equal sign")," ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," (i.e. the expression prefix). The text behind the equal sign is the actual expression. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"= remaingTime")," defines the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"remaingTime")," that accesses a variable with the name ",(0,i.kt)("inlineCode",{parentName:"p"},"remaingTime"),"."),(0,i.kt)("p",null,"If the value doesn't have the prefix then it is used as static value. A static value is used either as a string (e.g. job type) or as a number (e.g. job retries). A string value must not be enclosed in quotes."),(0,i.kt)("p",null,"Note that an expression can also define a static value by using literals (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},'"foo"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},"21"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[1,2,3]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"{x: 22}"),", etc.)."),(0,i.kt)("h2",{id:"the-expression-language"},"The Expression Language"),(0,i.kt)("p",null,"An expression is written in ",(0,i.kt)("strong",{parentName:"p"},"FEEL")," (Friendly Enough Expression Language). FEEL is part of the OMG's DMN (Decision Model and Notation) specification. It is designed to have the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Side-effect free"),(0,i.kt)("li",{parentName:"ul"},"Simple data model with JSON-like object types: numbers, dates, strings, lists, and contexts"),(0,i.kt)("li",{parentName:"ul"},"Simple syntax designed for business professionals and developers"),(0,i.kt)("li",{parentName:"ul"},"Three-valued logic (true, false, null)")),(0,i.kt)("p",null,"Zeebe integrates the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/camunda/feel-scala"},"Feel-Scala")," engine (version ",(0,i.kt)("inlineCode",{parentName:"p"},"1.12.x"),") to evaluate FEEL expressions. The following sections cover common use cases in Zeebe. A complete list of supported expressions can be found in the project's ",(0,i.kt)("a",{parentName:"p",href:"https://camunda.github.io/feel-scala/docs/reference/"},"documentation"),"."),(0,i.kt)("h3",{id:"access-variables"},"Access Variables"),(0,i.kt)("p",null,"A variable can be accessed by its name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'owner\n// "Paul"\n\ntotalPrice\n// 21.2\n\nitems\n// ["item-1", "item-2", "item-3"]\n')),(0,i.kt)("p",null,"If a variable is a JSON document/object then it is handled as a FEEL context. A property of the context (aka nested variable property) can be accessed by ",(0,i.kt)("inlineCode",{parentName:"p"},".")," (a dot) and the property name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'order.id\n// "order-123"\n\norder.customer.name\n// "Paul"\n')),(0,i.kt)("h3",{id:"boolean-expressions"},"Boolean Expressions"),(0,i.kt)("p",null,"Values can be compared using the following operators:"),(0,i.kt)("table",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Operator"),(0,i.kt)("th",null,"Description"),(0,i.kt)("th",null,"Example")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"= (only ",(0,i.kt)("b",null,"one")," equal sign)"),(0,i.kt)("td",null,"equal to"),(0,i.kt)("td",null,'owner = "Paul"')),(0,i.kt)("tr",null,(0,i.kt)("td",null,"!="),(0,i.kt)("td",null,"not equal to"),(0,i.kt)("td",null,'owner != "Paul"')),(0,i.kt)("tr",null,(0,i.kt)("td",null,"<"),(0,i.kt)("td",null,"less than"),(0,i.kt)("td",null,"totalPrice < 25")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"<="),(0,i.kt)("td",null,"less than or equal to"),(0,i.kt)("td",null,"totalPrice <= 25")),(0,i.kt)("tr",null,(0,i.kt)("td",null,">"),(0,i.kt)("td",null,"greater than"),(0,i.kt)("td",null,"totalPrice > 25")),(0,i.kt)("tr",null,(0,i.kt)("td",null,">="),(0,i.kt)("td",null,"greater than or equal to"),(0,i.kt)("td",null,"totalPrice >= 25")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"between _ and _"),(0,i.kt)("td",null,"same as ",(0,i.kt)("i",null,"(x >= _ and x <= _)")),(0,i.kt)("td",null,"totalPrice between 10 and 25"))),(0,i.kt)("p",null,"Multiple boolean values can be combined as disjunction (",(0,i.kt)("inlineCode",{parentName:"p"},"and"),") or conjunction (",(0,i.kt)("inlineCode",{parentName:"p"},"or"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},"orderCount >= 5 and orderCount < 15\n\norderCount > 15 or totalPrice > 50\n")),(0,i.kt)("h3",{id:"null-checks"},"Null Checks"),(0,i.kt)("p",null,"If a variable or a nested property can be ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," then it can be compared to the ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," value. Comparing ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," to a value different from ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," results in ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'order = null\n// true - if "order" is null or doesn\'t exist\n\norder.id = null\n// true - if "order" is null, "order" doesn\'t exist,\n//           "id" is null, or "order" has no property "id"\n')),(0,i.kt)("p",null,"In addition to the comparison with ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", the built-in function ",(0,i.kt)("inlineCode",{parentName:"p"},"is defined()")," can be used to differentiate between a value that is ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," and a value that doesn\u2019t exist."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'is defined(order)\n// true - if "order" has any value or is null\n\nis defined(order.id)\n// false - if "order" doesn\'t exist or it has no property "id"\n')),(0,i.kt)("h3",{id:"string-expressions"},"String Expressions"),(0,i.kt)("p",null,"A string value must be enclosed in double quotes. Multiple string values can be concatenated using the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'"foo" + "bar"\n// "foobar"\n')),(0,i.kt)("p",null,"Any value can be transformed into a string value using the ",(0,i.kt)("inlineCode",{parentName:"p"},"string()")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'"order-" + string(orderId)\n// "order-123"\n')),(0,i.kt)("p",null,"More functions for string values are available as ",(0,i.kt)("a",{parentName:"p",href:"https://camunda.github.io/feel-scala/1.12/feel-built-in-functions#string-functions"},"built-in functions")," (e.g. contains, matches, etc.)."),(0,i.kt)("h3",{id:"temporal-expressions"},"Temporal Expressions"),(0,i.kt)("p",null,"The following operators can be applied on temporal values:"),(0,i.kt)("table",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Temporal Type"),(0,i.kt)("th",null,"Examples"),(0,i.kt)("th",null,"Operators")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"date"),(0,i.kt)("td",null,'date("2020-04-06")'),(0,i.kt)("td",null,(0,i.kt)("li",null,"date + duration"),(0,i.kt)("li",null,"date - date"),(0,i.kt)("li",null,"date - duration"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"time"),(0,i.kt)("td",null,'time("15:30:00"),',(0,i.kt)("br",null),'time("15:30:00+02:00"),',(0,i.kt)("br",null),'time("15:30:00@Europe/Berlin")'),(0,i.kt)("td",null,(0,i.kt)("li",null,"time + duration"),(0,i.kt)("li",null,"time - time"),(0,i.kt)("li",null,"time - duration"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"date-time"),(0,i.kt)("td",null,'date and time("2020-04-06T15:30:00"),',(0,i.kt)("br",null),'date and time("2020-04-06T15:30:00+02:00"),',(0,i.kt)("br",null),'date and time("2020-04-06T15:30:00@UTC")'),(0,i.kt)("td",null,(0,i.kt)("li",null,"date-time + duration"),(0,i.kt)("li",null,"date-time - date-time"),(0,i.kt)("li",null,"date-time - duration"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"duration"),(0,i.kt)("td",null,'duration("P12H"),',(0,i.kt)("br",null),' duration("P4Y")'),(0,i.kt)("td",null,(0,i.kt)("li",null,"duration + duration"),(0,i.kt)("li",null,"duration + date"),(0,i.kt)("li",null,"duration + time"),(0,i.kt)("li",null,"duration + date-time"),(0,i.kt)("li",null,"duration - duration"),(0,i.kt)("li",null,"date - duration"),(0,i.kt)("li",null,"time - duration"),(0,i.kt)("li",null,"date-time - duration"),(0,i.kt)("li",null,"duration * number"),(0,i.kt)("li",null,"duration / duration"),(0,i.kt)("li",null,"duration / number"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"cycle"),(0,i.kt)("td",null,'cycle(3, duration("PT1H")),',(0,i.kt)("br",null),' cycle(duration("P7D"))'),(0,i.kt)("td",null," "))),(0,i.kt)("p",null,"A temporal value can be compared in a boolean expression with another temporal value of the same type."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"cycle")," type is different from the other temporal types because it is not supported in the FEEL type system. Instead, it is defined as a function that returns the definition of the cycle as a string in the ISO 8601 format of a recurring time interval. The function expects two arguments: the number of repetitions and the recurring interval as duration. If the first argument is ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or not passed in then the interval is unbounded (i.e. infinitely repeated)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'cycle(3, duration("PT1H"))\n// "R3/PT1H"\n\ncycle(duration("P7D"))\n// "R/P7D"\n')),(0,i.kt)("p",null,"The current date and date-time can be accessed using the built-in functions ",(0,i.kt)("inlineCode",{parentName:"p"},"today()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"now()"),". In order to store the current date or date-time in a variable, it must be converted to a string using the built-in function ",(0,i.kt)("inlineCode",{parentName:"p"},"string()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'now()\n// date and time("2020-04-06T15:30:00@UTC")\n\ntoday()\n// date("2020-04-06")\n\nstring(today())\n// "2020-04-06"\n')),(0,i.kt)("h3",{id:"list-expressions"},"List Expressions"),(0,i.kt)("p",null,"An element of a list can be accessed by its index. The index starts at ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," with the first element (",(0,i.kt)("strong",{parentName:"p"},"not")," at ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"). A negative index starts at the end by ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),". If the index is out of the range of the list then ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," is returned instead."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'["a","b","c"][1]\n// "a"\n\n["a","b","c"][2]\n// "b"\n\n["a","b","c"][-1]\n// "c"\n')),(0,i.kt)("p",null,"A list value can be filtered using a boolean expression. The result is a list of elements that fulfill the condition. The current element in the condition is assigned to the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"item"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},"[1,2,3,4][item > 2]\n// [3,4]\n")),(0,i.kt)("p",null,"The operators ",(0,i.kt)("inlineCode",{parentName:"p"},"every")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"some")," can be used to test if all elements or at least one element of a list fulfill a given condition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},"every x in [1,2,3] satisfies x >= 2\n// false\n\nsome x in [1,2,3] satisfies x > 2\n// true\n")),(0,i.kt)("h3",{id:"invoke-functions"},"Invoke Functions"),(0,i.kt)("p",null,"FEEL defines a set of ",(0,i.kt)("a",{parentName:"p",href:"https://camunda.github.io/feel-scala/1.12/feel-built-in-functions"},"built-in functions")," to convert values and to apply different operations on specific value types in addition to the operators."),(0,i.kt)("p",null,"A function can be invoked by its name followed by the arguments. The arguments can be assigned to the function parameters either by their position or by defining the parameter names."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-feel"},'floor(1.5)\n// 1\n\ncount(["a","b","c"])\n// 3\n\nappend(["a","b"], "c")\n// ["a","b","c"]\n\ncontains(string: "foobar", match: "foo")\n// true\n')),(0,i.kt)("h2",{id:"additional-resources"},"Additional Resources"),(0,i.kt)("p",null,"References:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://camunda.github.io/feel-scala/1.12/"},"FEEL-Scala - Documentation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://camunda.github.io/feel-scala/1.12/feel-data-types"},"FEEL - Data Types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://camunda.github.io/feel-scala/1.12/feel-expression"},"FEEL - Expressions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://camunda.github.io/feel-scala/1.12/feel-built-in-functions"},"FEEL - Built-in Functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.omg.org/spec/DMN/About-DMN/"},"DMN Specification"))))}c.isMDXComponent=!0}}]);