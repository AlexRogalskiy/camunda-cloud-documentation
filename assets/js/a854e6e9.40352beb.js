(self.webpackChunkcamunda_cloud_documentation=self.webpackChunkcamunda_cloud_documentation||[]).push([[17788],{3905:function(e,t,r){"use strict";r.d(t,{Zo:function(){return p},kt:function(){return d}});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),l=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=l(r),d=o,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||a;return r?n.createElement(f,i(i({ref:t},p),{},{components:r})):n.createElement(f,i({ref:t},p))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var l=2;l<a;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},33789:function(e,t,r){"use strict";r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return l},default:function(){return u}});var n=r(22122),o=r(19756),a=(r(67294),r(3905)),i={id:"clustering",title:"Clustering"},c=void 0,s={unversionedId:"product-manuals/zeebe/technical-concepts/clustering",id:"version-0.26/product-manuals/zeebe/technical-concepts/clustering",isDocsHomePage:!1,title:"Clustering",description:"Zeebe can operate as a cluster of brokers, forming a peer-to-peer network.",source:"@site/versioned_docs/version-0.26/product-manuals/zeebe/technical-concepts/clustering.md",sourceDirName:"product-manuals/zeebe/technical-concepts",slug:"/product-manuals/zeebe/technical-concepts/clustering",permalink:"/docs/0.26/product-manuals/zeebe/technical-concepts/clustering",editUrl:"https://github.com/camunda-cloud/camunda-cloud-documentation/edit/master/versioned_docs/version-0.26/product-manuals/zeebe/technical-concepts/clustering.md",version:"0.26",frontMatter:{id:"clustering",title:"Clustering"},sidebar:"version-0.26/Product Manuals",previous:{title:"Architecture",permalink:"/docs/0.26/product-manuals/zeebe/technical-concepts/architecture"},next:{title:"Partitions",permalink:"/docs/0.26/product-manuals/zeebe/technical-concepts/partitions"}},l=[{value:"Gossip membership protocol",id:"gossip-membership-protocol",children:[]},{value:"Raft consensus and replication protocol",id:"raft-consensus-and-replication-protocol",children:[]},{value:"Commit",id:"commit",children:[]}],p={toc:l};function u(e){var t=e.components,i=(0,o.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Zeebe can operate as a cluster of brokers, forming a peer-to-peer network.\nIn this network, all brokers have the same responsibilities and there is no single point of failure."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"cluster",src:r(40230).Z})),(0,a.kt)("h2",{id:"gossip-membership-protocol"},"Gossip membership protocol"),(0,a.kt)("p",null,"Zeebe implements the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Gossip_protocol"},"Gossip protocol")," to know which brokers are currently part of the cluster."),(0,a.kt)("p",null,"The cluster is bootstrapped using a set of well-known bootstrap brokers, to which the other ones can connect. To achieve this, each broker must have at least one bootstrap broker as its initial contact point in their configuration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"---\ncluster:\n  initialContactPoints: [node1.mycluster.loc:26502]\n")),(0,a.kt)("p",null,"When a broker is connected to the cluster for the first time, it fetches the topology from the initial contact points and then starts gossiping with the other brokers. Brokers keep cluster topology locally across restarts."),(0,a.kt)("h2",{id:"raft-consensus-and-replication-protocol"},"Raft consensus and replication protocol"),(0,a.kt)("p",null,"To ensure fault tolerance, Zeebe replicates data across machines using the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Raft_(computer_science)"},"Raft protocol"),"."),(0,a.kt)("p",null,"Data is divided into partitions (shards). Each partition has a number of replicas. Among the replica set, a ",(0,a.kt)("em",{parentName:"p"},"leader")," is determined by the raft protocol which takes in requests and performs all of the processing. All other brokers are passive ",(0,a.kt)("em",{parentName:"p"},"followers"),". When the leader becomes unavailable, the followers transparently select a new leader."),(0,a.kt)("p",null,"Each broker in the cluster may be both leader and follower at the same time for different partitions. In an ideal world, this leads to client traffic distributed evenly across all brokers."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"cluster",src:r(21117).Z})),(0,a.kt)("p",null,"Note, however, that there is no active load balancing across partitions. Each leader election for any partition is completely autonomous and independent of leader elections for other partitions. This may lead, in the worst case, to one node becoming the leader for all partitions. This is not a problem for fault tolerance as the guarantees of replication still hold. However, it may negatively impact throughput as all traffic hits one node."),(0,a.kt)("h2",{id:"commit"},"Commit"),(0,a.kt)("p",null,"Before a new record on a partition can be processed, it must be replicated to a quorum (typically majority) of followers. This procedure is called ",(0,a.kt)("em",{parentName:"p"},"commit"),". Committing ensures that a record is durable even in case of complete data loss on an individual broker. The exact semantics of committing are defined by the raft protocol."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"cluster",src:r(89049).Z})))}u.isMDXComponent=!0},40230:function(e,t,r){"use strict";t.Z=r.p+"assets/images/cluster-7f2aec7878e5ccbe062a37e916e596a5.png"},89049:function(e,t,r){"use strict";t.Z=r.p+"assets/images/commit-6ad408af956ff5a2e13674feb7ee5476.png"},21117:function(e,t,r){"use strict";t.Z=r.p+"assets/images/data-distribution-245d7f600a1a13ce2a904cb22039703f.png"}}]);