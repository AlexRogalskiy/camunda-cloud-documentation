(self.webpackChunkcamunda_cloud_documentation=self.webpackChunkcamunda_cloud_documentation||[]).push([[59120],{3905:function(e,t,r){"use strict";r.d(t,{Zo:function(){return u},kt:function(){return f}});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),s=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(r),f=o,m=d["".concat(c,".").concat(f)]||d[f]||p[f]||a;return r?n.createElement(m,i(i({ref:t},u),{},{components:r})):n.createElement(m,i({ref:t},u))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=r[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},39359:function(e,t,r){"use strict";r.r(t),r.d(t,{frontMatter:function(){return i},metadata:function(){return l},toc:function(){return c},default:function(){return u}});var n=r(22122),o=r(19756),a=(r(67294),r(3905)),i={id:"job-worker",title:"Job worker"},l={unversionedId:"product-manuals/clients/java-client/job-worker",id:"version-1.0/product-manuals/clients/java-client/job-worker",isDocsHomePage:!1,title:"Job worker",description:"Related resources",source:"@site/versioned_docs/version-1.0/product-manuals/clients/java-client/job-worker.md",sourceDirName:"product-manuals/clients/java-client",slug:"/product-manuals/clients/java-client/job-worker",permalink:"/docs/1.0/product-manuals/clients/java-client/job-worker",editUrl:"https://github.com/camunda-cloud/camunda-cloud-documentation/edit/master/versioned_docs/version-1.0/product-manuals/clients/java-client/job-worker.md",version:"1.0",frontMatter:{id:"job-worker",title:"Job worker"}},c=[{value:"Related resources",id:"related-resources",children:[]},{value:"The Java client&#39;s job worker",id:"the-java-clients-job-worker",children:[]},{value:"Example usage",id:"example-usage",children:[]},{value:"Backoff configuration",id:"backoff-configuration",children:[]}],s={toc:c};function u(e){var t=e.components,r=(0,o.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,n.Z)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"related-resources"},"Related resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.0/product-manuals/concepts/job-workers"},"Job worker basics"))),(0,a.kt)("h2",{id:"the-java-clients-job-worker"},"The Java client's job worker"),(0,a.kt)("p",null,"The Java client provides a job worker that takes care of polling for available jobs and allows you to focus on writing code to handle the activated jobs."),(0,a.kt)("p",null,"On ",(0,a.kt)("inlineCode",{parentName:"p"},"open")," the job worker waits ",(0,a.kt)("inlineCode",{parentName:"p"},"pollInterval")," milliseconds and then polls for ",(0,a.kt)("inlineCode",{parentName:"p"},"maxJobsActive")," jobs.\nIt then continues with the following schedule:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"when a poll did not activate any jobs, it waits for ",(0,a.kt)("inlineCode",{parentName:"li"},"pollInterval")," milliseconds and then polls for more jobs."),(0,a.kt)("li",{parentName:"ul"},"when a poll activated jobs, the worker submits each job to the job handler.\nEvery time a job is handled, the worker checks whether the number of unhandled jobs have dropped below 30% of ",(0,a.kt)("inlineCode",{parentName:"li"},"maxJobsActive"),".\nThe first time that happens, it will poll for more jobs."),(0,a.kt)("li",{parentName:"ul"},"when a poll fails with an error response, a backoff strategy is applied.\nIt waits for the delay provided by the ",(0,a.kt)("inlineCode",{parentName:"li"},"backoffSupplier")," and then polls for more jobs.")),(0,a.kt)("h2",{id:"example-usage"},"Example usage"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/1.0/product-manuals/clients/java-client-examples/job-worker-open"},"Open a job worker"))),(0,a.kt)("h2",{id:"backoff-configuration"},"Backoff configuration"),(0,a.kt)("p",null,"When a poll fails with an error response, the job worker applies a backoff strategy.\nIt waits for some time, after which it polls again for more jobs.\nThis gives a Zeebe cluster some time to recover from a failure.\nIn some cases, you may want to configure this backoff strategy to better fit your situation."),(0,a.kt)("p",null,"The retry delay (i.e. the time the job worker waits after an error before the next poll for new jobs) is provided by the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeebe-io/zeebe/blob/develop/clients/java/src/main/java/io/zeebe/client/api/worker/BackoffSupplier.java"},(0,a.kt)("inlineCode",{parentName:"a"},"BackoffSupplier")),".\nYou can replace it using the ",(0,a.kt)("inlineCode",{parentName:"p"},".backoffSupplier()")," method on the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeebe-io/zeebe/blob/develop/clients/java/src/main/java/io/zeebe/client/api/worker/JobWorkerBuilderStep1.java"},(0,a.kt)("inlineCode",{parentName:"a"},"JobWorkerBuilder")),".\nBy default, the job worker uses an exponential backoff implementation, which can you can configure using ",(0,a.kt)("inlineCode",{parentName:"p"},"BackoffSupplier.newBackoffBuilder()"),"."),(0,a.kt)("p",null,"The backoff strategy is especially useful for dealing with the ",(0,a.kt)("inlineCode",{parentName:"p"},"GRPC_STATUS_RESOURCE_EXHAUSTED")," error response (see ",(0,a.kt)("a",{parentName:"p",href:"../../../reference/grpc#technical-error-handling"},"gRPC Technical Error Handling"),").\nThis error code indicates the Zeebe cluster is currently under too much load and has decided to reject this request.\nBy backing off, the job worker helps Zeebe by reducing the load.\nNote, that Zeebe's ",(0,a.kt)("a",{parentName:"p",href:"../../zeebe/deployment-guide/operations/backpressure"},"backpressure mechanism")," can also be configured."))}u.isMDXComponent=!0}}]);