(self.webpackChunkcamunda_cloud_documentation=self.webpackChunkcamunda_cloud_documentation||[]).push([[48826],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return m},kt:function(){return s}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=d(n),s=r,h=u["".concat(p,".").concat(s)]||u[s]||c[s]||o;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function s(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},24909:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return d},default:function(){return c}});var a=n(22122),r=n(19756),o=(n(67294),n(3905)),i={id:"importer-and-archiver",title:"Importer and archiver",description:"Let's analyze how Operate is organized by modules to import and archive data."},l=void 0,p={unversionedId:"components/operate/deployment/importer-and-archiver",id:"components/operate/deployment/importer-and-archiver",isDocsHomePage:!1,title:"Importer and archiver",description:"Let's analyze how Operate is organized by modules to import and archive data.",source:"@site/docs/components/operate/deployment/importer-and-archiver.md",sourceDirName:"components/operate/deployment",slug:"/components/operate/deployment/importer-and-archiver",permalink:"/docs/components/operate/deployment/importer-and-archiver",editUrl:"https://github.com/camunda-cloud/camunda-cloud-documentation/edit/master/docs/components/operate/deployment/importer-and-archiver.md",version:"current",frontMatter:{id:"importer-and-archiver",title:"Importer and archiver",description:"Let's analyze how Operate is organized by modules to import and archive data."},sidebar:"Components",previous:{title:"Schema and migration",permalink:"/docs/components/operate/deployment/schema-and-migration"},next:{title:"Authentication",permalink:"/docs/components/operate/deployment/authentication"}},d=[],m={toc:d};function c(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Operate consists of three modules:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Webapp"),": Contains the UI and operation executor functionality."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Importer"),": Responsible for importing data from Zeebe."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Archiver"),': Responsible for archiving "old" data (finished process instances and user operations.) See ',(0,o.kt)("a",{parentName:"li",href:"/docs/components/operate/deployment/data-retention"},"Data retention"),".")),(0,o.kt)("p",null,"Modules can be run together or separately in any combination and can be scaled. When you run an Operate instance, by default, all modules are enabled. To disable them, use the following configuration parameters:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Configuration parameter"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"),(0,o.kt)("th",{parentName:"tr",align:null},"Default value"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.importerEnabled"),(0,o.kt)("td",{parentName:"tr",align:null},"When true, Importer module is enabled."),(0,o.kt)("td",{parentName:"tr",align:null},"True")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.archiverEnabled"),(0,o.kt)("td",{parentName:"tr",align:null},"When true, Archiver module is enabled."),(0,o.kt)("td",{parentName:"tr",align:null},"True")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.webappEnabled"),(0,o.kt)("td",{parentName:"tr",align:null},"When true, Webapp module is enabled."),(0,o.kt)("td",{parentName:"tr",align:null},"True")))),(0,o.kt)("p",null,"Additionally, you can have several importer and archiver nodes to increase throughput. Internally, they will spread their work based on Zeebe partitions."),(0,o.kt)("p",null,"For example, if your Zeebe runs 10 partitions and you configure two importer nodes, they will import data from five partitions each."),(0,o.kt)("p",null,"Each single importer/archiver node must be configured using the following configuration parameters:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Configuration parameter"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"),(0,o.kt)("th",{parentName:"tr",align:null},"Default value"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.clusterNode.partitionIds"),(0,o.kt)("td",{parentName:"tr",align:null},"Array of Zeebe partition ids this Importer (or Archiver) node must be responsible for."),(0,o.kt)("td",{parentName:"tr",align:null},"Empty array, meaning all partitions data is loaded.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.clusterNode.nodeCount"),(0,o.kt)("td",{parentName:"tr",align:null},"Total amount of Importer (or Archiver) nodes in the cluster."),(0,o.kt)("td",{parentName:"tr",align:null},"1")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.clusterNode.currentNodeId"),(0,o.kt)("td",{parentName:"tr",align:null},"Id of current Importer (or Archiver) node, starting from 0."),(0,o.kt)("td",{parentName:"tr",align:null},"0")))),(0,o.kt)("p",null,"It's enough to configure either ",(0,o.kt)("inlineCode",{parentName:"p"},"partitionIds")," or a pair of ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeCount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"currentNodeId"),". If you provide ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeCount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"currentNodeId"),", each node will automatically guess the Zeebe partitions they're responsible for."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},(0,o.kt)("inlineCode",{parentName:"p"},"nodeCount")," always represents the number of nodes of one specific type."))),(0,o.kt)("p",null,"For example, the configuration of a cluster with one Webapp node, two Importer nodes, and one Archiver node could look like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Webapp node\n\ncamunda.operate:\n  archiverEnabled: false\n  importerEnabled: false\n  #other configuration...\n\nImporter node #1\n\ncamunda.operate:\n  archiverEnabled: false\n  webappEnabled: false\n  clusterNode:\n    nodeCount: 2\n    currentNodeId: 0\n  #other configuration...\n  \nImporter node #2\n\ncamunda.operate:\n  archiverEnabled: false\n  webappEnabled: false\n  clusterNode:\n    nodeCount: 2\n    currentNodeId: 1\n  #other configuration...\n  \nArchiver node\n\ncamunda.operate:\n  webappEnabled: false\n  importerEnabled: false\n  \n")),(0,o.kt)("p",null,"You can further parallelize archiver and/or importer within one node using the following configuration parameters:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Configuration parameter"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"),(0,o.kt)("th",{parentName:"tr",align:null},"Default value"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.archiver.threadsCount"),(0,o.kt)("td",{parentName:"tr",align:null},"Number of threads in which data will be archived."),(0,o.kt)("td",{parentName:"tr",align:null},"1")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"camunda.operate.importer.threadsCount"),(0,o.kt)("td",{parentName:"tr",align:null},"Number of threads in which data will be imported."),(0,o.kt)("td",{parentName:"tr",align:null},"3")))),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Parallelization of import and archiving within one node will also happen based on Zeebe partitions, meaning only configurations with (number of nodes) * (threadsCount) <= (total number of Zeebe partitions) will make sense. Too many threads and nodes will still work, but some of them will be idle."))))}c.isMDXComponent=!0}}]);