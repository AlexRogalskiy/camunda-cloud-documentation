(self.webpackChunkcamunda_cloud_documentation=self.webpackChunkcamunda_cloud_documentation||[]).push([[22697],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(n),d=a,h=u["".concat(c,".").concat(d)]||u[d]||m[d]||s;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},84562:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return i},toc:function(){return c},default:function(){return p}});var r=n(22122),a=n(19756),s=(n(67294),n(3905)),o={id:"internal-processing",title:"Internal processing"},i={unversionedId:"product-manuals/zeebe/technical-concepts/internal-processing",id:"version-0.26/product-manuals/zeebe/technical-concepts/internal-processing",isDocsHomePage:!1,title:"Internal processing",description:"Internally, Zeebe is implemented as a collection of stream processors working on record streams \\(partitions\\). The stream processing model is used since it is a unified approach to provide:",source:"@site/versioned_docs/version-0.26/product-manuals/zeebe/technical-concepts/internal-processing.md",sourceDirName:"product-manuals/zeebe/technical-concepts",slug:"/product-manuals/zeebe/technical-concepts/internal-processing",permalink:"/docs/0.26/product-manuals/zeebe/technical-concepts/internal-processing",editUrl:"https://github.com/camunda-cloud/camunda-cloud-documentation/edit/master/versioned_docs/version-0.26/product-manuals/zeebe/technical-concepts/internal-processing.md",version:"0.26",frontMatter:{id:"internal-processing",title:"Internal processing"},sidebar:"version-0.26/Product Manuals",previous:{title:"Partitions",permalink:"/docs/0.26/product-manuals/zeebe/technical-concepts/partitions"},next:{title:"Workflow lifecycles",permalink:"/docs/0.26/product-manuals/zeebe/technical-concepts/workflow-lifecycles"}},c=[{value:"State machines",id:"state-machines",children:[]},{value:"Events and commands",id:"events-and-commands",children:[]},{value:"Stateful stream processing",id:"stateful-stream-processing",children:[]},{value:"Command triggers",id:"command-triggers",children:[]},{value:"Handling back-pressure",id:"handling-back-pressure",children:[]}],l={toc:c};function p(e){var t=e.components,o=(0,a.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,r.Z)({},l,o,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Internally, Zeebe is implemented as a collection of ",(0,s.kt)("em",{parentName:"p"},"stream processors")," working on record streams ","(","partitions",")",". The stream processing model is used since it is a unified approach to provide:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Command protocol ","(","request-response",")",","),(0,s.kt)("li",{parentName:"ul"},"Record export ","(","streaming",")",","),(0,s.kt)("li",{parentName:"ul"},"Workflow evaluation ","(","asynchronous background tasks",")")),(0,s.kt)("p",null,"Record export solves the history problem - the stream provides exactly the kind of exhaustive audit log that a workflow engine needs to produce."),(0,s.kt)("h2",{id:"state-machines"},"State machines"),(0,s.kt)("p",null,"Zeebe manages stateful entities: jobs, workflows, etc. Internally, these entities are implemented as ",(0,s.kt)("em",{parentName:"p"},"state machines")," managed by a stream processor."),(0,s.kt)("p",null,"The concept of the state machine pattern is simple. An instance of a state machine is always in one of several logical states. From each state, a set of transitions defines the next possible states. Transitioning into a new state may produce outputs/side effects."),(0,s.kt)("p",null,"Let's look at the state machine for jobs. Simplified, it looks as follows:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"partition",src:n(84945).Z})),(0,s.kt)("p",null,"Every oval is a state. Every arrow is a state transition. Note how each state transition is only applicable in a specific state. For example, it is not possible to complete a job when it is in state ",(0,s.kt)("inlineCode",{parentName:"p"},"CREATED"),"."),(0,s.kt)("h2",{id:"events-and-commands"},"Events and commands"),(0,s.kt)("p",null,"Every state change in a state machine is called an ",(0,s.kt)("em",{parentName:"p"},"event"),". Zeebe publishes every event as a record on the stream."),(0,s.kt)("p",null,"State changes can be requested by submitting a ",(0,s.kt)("em",{parentName:"p"},"command"),". A Zeebe broker receives commands from two sources:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Clients send commands remotely. Examples: Deploying workflows, starting workflow instances, creating and completing jobs, etc."),(0,s.kt)("li",{parentName:"ul"},"The broker itself generates commands. Examples: Locking a job for exclusive processing by a worker, etc.")),(0,s.kt)("p",null,"Once received, a command is published as a record on the addressed stream."),(0,s.kt)("h2",{id:"stateful-stream-processing"},"Stateful stream processing"),(0,s.kt)("p",null,"A stream processor reads the record stream sequentially and interprets the commands with respect to the addressed entity's lifecycle. More specifically, a stream processor repeatedly performs the following steps:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Consume the next command from the stream."),(0,s.kt)("li",{parentName:"ol"},"Determine whether the command is applicable based on the state lifecycle and the entity's current state."),(0,s.kt)("li",{parentName:"ol"},"If the command is applicable, apply it to the state machine. If the command was sent by a client, send a reply/response."),(0,s.kt)("li",{parentName:"ol"},"If the command is not applicable, reject it. If it was sent by a client, send an error reply/response."),(0,s.kt)("li",{parentName:"ol"},"Publish an event reporting the entity's new state.")),(0,s.kt)("p",null,"For example, processing the ",(0,s.kt)("em",{parentName:"p"},"Create Job")," command produces the event ",(0,s.kt)("em",{parentName:"p"},"Job Created"),"."),(0,s.kt)("h2",{id:"command-triggers"},"Command triggers"),(0,s.kt)("p",null,"A state change which occurred in one entity can automatically trigger a command for another entity. "),(0,s.kt)("p",null,"For example, when a job is completed, the corresponding workflow instance shall continue with the next step. Thus, the Event ",(0,s.kt)("em",{parentName:"p"},"Job Completed")," triggers the command ",(0,s.kt)("em",{parentName:"p"},"Complete Activity"),"."),(0,s.kt)("h2",{id:"handling-back-pressure"},"Handling back-pressure"),(0,s.kt)("p",null,"When a broker receives a client request, it is written to the ",(0,s.kt)("em",{parentName:"p"},"event stream")," first, and processed later by the stream processor.\nIf the processing is slow or if there are many client requests in the stream, it might take too long for the processor to start processing the command.\nIf the broker keeps accepting new requests from the client, the back log increases and the processing latency can grow beyond an acceptable time.\nTo avoid such problems, Zeebe employs a back-pressure mechanism.\nWhen the broker receives more requests than it can process with an acceptable latency, it rejects some requests."),(0,s.kt)("p",null,"The maximum rate of requests that can be processed by a broker depends on the processing capacity of the machine, the network latency, current load of the system and so on.\nHence, there is no fixed limit configured in Zeebe for the maximum rate of requests it accepts.\nInstead, Zeebe uses an adaptive algorithm to dynamically determine the limit of the number of inflight requests (the requests that are accepted by the broker, but not yet processed).\nThe inflight request count is incremented when a request is accepted and decremented when a response is sent back to the client.\nThe broker rejects requests when the inflight request count reaches the limit."),(0,s.kt)("p",null,"When the broker rejects requests due to back-pressure, the clients can retry them with an appropriate retry strategy.\nIf the rejection rate is high, it indicates that the broker is constantly under high load.\nIn that case, it is recommended to reduce the request rate."))}p.isMDXComponent=!0},84945:function(e,t,n){"use strict";t.Z=n.p+"assets/images/internal-processing-job-5c7cc582b13160d2ad476726ff8ec118.png"}}]);